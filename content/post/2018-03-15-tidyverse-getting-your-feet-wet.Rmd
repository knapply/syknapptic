---
title: 'Tidyverse: Getting Your Feet Wet'
draft: false
author: Brendan Knapp
date: '2018-03-15'
slug: tidyverse-getting-your-feet-wet
categories:
  - data carpentry
tags:
  - tidyverse
  - ggplot
  - dplyr
  - tidyr
thumbnailImagePosition: left
thumbnailImage: http://res.cloudinary.com/syknapptic/image/upload/v1521124488/tidyverse_awesome_dukagq.png
metaAlignment: center
coverMeta: out
summary: A (hopefully) gentle introduction to R's tidyverse that I as a primer for a short series of workshops I taught.
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, 
                      fig.align = "center", fig.height = 9, fig.width = 11)
```

I recently had the opportunity to teach some tidyverse code to colleagues and classmates in a series of workshops. Some had already dabbled in R or other languages, but it was the first time that the majority of participants had written a single line of code.

In preparation for this workshop series, I found a lot of inspiration in [Michael Levy's presentation on teaching R](http://michaellevy.name/blog/useR-talk-on-teaching-R/), which itself echoes principles preached by other R advocates. 

One of my biggest takeaways is that __live coding works__.

Writing code in real time shows every single step we make from opening the IDE, to reshaping the data, to debugging inevitable errors, to rendering a final report.

Within a few short weeks of learning to code, it is surprising how many tiny steps become automatic and taken for granted. Tack on a couple more months and newcomers will think you're speaking in an entirely different language when you're explaining something requiring context they simply haven't yet encountered. Add a few years and... yeesh.

Something that frustrated me when I first started is that code explanations often seem to be written in such a way that dismisses how difficult the basics can be. I'm half-convinced that for some folks, the trauma was so great that they have simply blocked it from memory.

Live coding enforces a maximum speed in moving through exercises, which not only gives students more time to digest what you're doing. It also provides more opportunity to for them to ask questions on details you might find trivial, but only because you _already_ suffered through them.

I also think that the benefits of live coding go both ways. I found myself answering questions that framed things in ways that I had not even considered. Additionally, I have a better sense now of which concepts need to be covered in more detail, as they weren't necessarily as inuitive for others as they were for me. On the flip-side, concepts that I remember struggling with may not be difficult at all for others to understand.

I'll cut the bloggyness of this blog post here, and get to the meat of what we covered. Before I forget, the title image came originally from [R Memes for Statistical Fiends](https://www.facebook.com/Rmemes0/). If you're reading this, you'll likely find their memes of satisfactory dankness.

```{r}
# install.packages("devtools")
# install.packages("tidyverse")
library(tidyverse)
# loads {ggplot2}, {tibble}, {tidyr}, {readr}, {purrr}, {dplyr}, {stringr}, and {forcats}

# install.packages("gapminder")
library(gapminder)
# loads the gapminder data set


# install.packages("kableExtra")
library(knitr)
library(kableExtra)
# just to prettify printed tables when knitting

# library(scales)
```


# Workflow

![](/post/2018-03-15-tidyverse-getting-your-feet-wet_files/workflow_2.png)

![](/post/2018-03-15-tidyverse-getting-your-feet-wet_files/workflow.png)


![](/post/2018-03-15-tidyverse-getting-your-feet-wet_files/tidyverse_expanded.png)



# Resources Up Front

## Data Carpentry

[![](https://raw.githubusercontent.com/tidyverse/tidyr/master/man/figures/logo.png)](http://tidyr.tidyverse.org/) [![](https://raw.githubusercontent.com/tidyverse/dplyr/master/man/figures/logo.png)](http://dplyr.tidyverse.org/)

* [Cheat Sheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)

![](/post/2018-03-15-tidyverse-getting-your-feet-wet_files/data_carpentry.png)


## Plotting

[![](https://raw.githubusercontent.com/tidyverse/ggplot2/master/man/figures/logo.png)](http://ggplot2.tidyverse.org/)

* [Cheat Sheet](https://www.rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf)

![](/post/2018-03-15-tidyverse-getting-your-feet-wet_files/ggplot_cheat_sheet.png)



* [R Graph Catalog](http://shiny.stat.ubc.ca/r-graph-catalog/)

![](/post/2018-03-15-tidyverse-getting-your-feet-wet_files/r_graph_catalog.png)


<br><br><br><br>

# Gapminder Data

In the following exercises, `gm.data.frame` will be used to demonstrate actions that use `{base}` R methods for `data.frame` operations while `gm_df` will be used to to demonstrate `{tidyverse}` methods for `tibble` operations.

```{r}
gm.data.frame <- as.data.frame(gapminder)

gm_df <- gapminder
```


# `tibble`s

```{r}
class(gm.data.frame)

class(gm_df)
```

`tibble`s are opinionated `data.frame`s that keep everything that is helpful about `data.frames` changes what is unhelpful, and adds methods that makes thems even more useful.

Printing `gm.data.frame` dumps the whole data set to the console, typically requiring `head()` to limit the output.

### Printing

```{r}
head(gm.data.frame)
```


Printing the `gm_df` provides the dimensions, data type of each column, and only prints the first 10 rows.

```{r}
gm_df
```


# `%>%`

![](/post/2018-03-15-tidyverse-getting-your-feet-wet_files/magrittr.png)

The pipe (`%>%`) is used to chain operations together. Underneath the hood, it's taking the value on the left-hand side of `%>%` and using it as the first argument of the function on the right-hand side of `%>%`.

For example, these 2 lines are doing the exact same thing.

```{r}
head(gm_df)

gm_df %>% head()
```

For simple operations involving 1 function, `%>%` is only slightly beneficial in that it improves readability as the flow of operations go from left to right.

`%>%` become truly useful when you need to perform multiple operations in succession.

As an arbitrary example, let's say that we want to select the `head()` (first 6 rows) of `gm.data.frame` and convert it to a `tibble`.

Without `%>%`, we can do this in a few ways.

1. Use intermediate variables.
    + get `gm.data.frame`'s `head()` and assign it to `no_pipe_1`
    + convert `no_pipe_1` to a `tibble` with `as_tibble()` and assign it to `no_pipe_2`

```{r}
no_pipe_1 <- head(gm.data.frame)

no_pipe_2 <- as_tibble(no_pipe_1)

no_pipe_2
```

2. Nest `head()` inside of `as_tibble()`.

```{r}
as_tibble(head(gm.data.frame))
```

With `%>%`, we can chain these actions together in the order in which they occur, which is also the way we read English.

* Here, we do the same thing by:
    + taking `gm_df`
    + piping it to `head()` (keeping the top 6 rows)
    + piping it to `as_tibble()` (converting it to a `tibble` data frame)

```{r}
gm_df %>% head() %>% as_tibble()
```

In practice, it's usually best to place each of the functions on a separate line as it  facilitates debugging and further improves readability.

```{r}
gm_df %>%
  as_tibble() %>%
  head()
```

From here on, you'll notice `prettify()`. This is only being used to print tables in a clean format when the document is `knit()`ted. 

`data.frame`s will print a default maximum of 3 rows while `tibble`s will print a default maximum of 10 rows.

```{r}
prettify <- function(df, n = NULL, cols_changed = NULL, rows_changed = NULL){
  if(is.null(n)) n <- ifelse(is.tibble(df), 10, 3)
  pretty_df <- df %>%
    head(n) %>%
    kable(format = "html") %>%
    kable_styling(bootstrap_options = c("striped", "bordered", "condensed",
                                        "hover", "responsive"),
                  full_width = FALSE)
  
  if(!is.null(cols_changed)){
    pretty_df <- pretty_df %>%
      column_spec(cols_changed, bold = T, color = "black", background = "#C8FAE3")
  }
  
  if(!is.null(rows_changed)){
    pretty_df <- pretty_df %>%
      row_spec(rows_changed, bold = T, color = "black", background = "#C8FAE3")
  }
  
  return(pretty_df)
}
```

```{r}
gm.data.frame %>%
  prettify()

gm_df %>%
  prettify()
```

# Sample Data

You'll also see a toy data set for the introductory examples that start each section.

```{r}
sample_countries <- c("Tunisia", "Nicaragua", "Singapore", "Hungary", "New Zealand",
                      "Nigeria", "Brazil", "Sri Lanka", "Ireland", "Australia")
  
sample_df <- gm_df %>%
  filter(year == 2007,
         country %in% sample_countries)

sample_df %>%     
  prettify()
```


# "Tidy" Data

![](/post/2018-03-15-tidyverse-getting-your-feet-wet_files/tidy_data.png)


![](/post/2018-03-15-tidyverse-getting-your-feet-wet_files/tidy_data_2.png)

![](/post/2018-03-15-tidyverse-getting-your-feet-wet_files/messy_tidy.png)


With `tibble`s, `%>%`, and the concept of tidy data covered, let's take a dive.

# `{dplyr}`

![](/post/2018-03-15-tidyverse-getting-your-feet-wet_files/dplyr.png)


`{dplyr}` provides a grammar of data manipulation and a set of verb functions that solve most common data carpentry challenges in a consistent fashion.

* `glimpse()`
* `select()`
* `filter()`
* `arrange()`
* `mutate()`
* `summarize()`
* `group_by()`

# Taking a `glimpse()`

In addition to the `summary()`, `dim()`ensions, and `str()`ucture functions that can be used to inspect data, you can now use `{dplyr}`'s `glimpse()`.

```{r}
summary(gm.data.frame)
dim(gm.data.frame)
str(gm.data.frame)

glimpse(gm_df)
```

# `select()` columns

![](/post/2018-03-15-tidyverse-getting-your-feet-wet_files/select.png)

## Quick Example

### Initial Data

```{r}
sample_df %>%
  prettify()
```

### End Data

```{r}
sample_df %>%
  select(country, pop) %>%
  prettify()
```



The `select()` family is used to choose columns to keep. You can use bare (unquoted) names.

* `select()` columns by specific names.
    + select only `gm_df`'s `country` and `pop` columns

```{r}
gm_df %>%
  select(country, year, pop) %>%                  # select columns by specific names
  prettify()
```

* `select()` a range of columns by name
    + select `gm_df`'s `continent` column and all columns from `lifeExp` to `gdpPercap`

```{r}
gm_df %>%
  select(continent, lifeExp:gdpPercap) %>%  # select columns name range
  prettify()
```

* de`select()` a column with `-`
    + `select()` all of `gm_df`'s columns except `lifeExp`

```{r}
gm_df %>%
  select(-lifeExp) %>%                      # deselect column by name
  prettify()
```

* de`select()` a range of columns by name
    + `select()` all of `gm_df`'s columns except those between `lifeExp` and `gdpPercap`

```{r}
gm_df %>%
  select(-c(lifeExp:gdpPercap)) %>%            # deselect column by name range
  prettify()
```

* `select()` column by index
    + `select()` `gm_df`'s `4`th column

```{r}
gm_df %>%
  select(4) %>%                             # select column by index
  prettify()
```

* de`select()` a column by index
    + `select()` all of `gm_df`'s columns except for the `4`th column

```{r}
gm_df %>%
  select(-4) %>%                            # deselect column by index
  prettify()
```

* de`select()` a range of columns by index
    + `select()` all of `gm_df`'s columns except those between the `3`rd and `5`th columns

```{r}
gm_df %>%
  select(-c(3:5)) %>%                    # deselect columns by index range
  prettify()
```

# `ggplot()` Exercise 1

`{ggplot2}` is monster of a package used for data visualization that follows [The Grammar of Graphics](https://www.amazon.com/Grammar-Graphics-Statistics-Computing/dp/0387245448). 

`{ggplot2}` takes R's powerful graphics capabilities and makes them more accessible by taking care of many plotting tasks that are often tedious, while allowing for deep, lower-level customization.



* Basic Setup

![](/post/2018-03-15-tidyverse-getting-your-feet-wet_files/ggplot_exercise_1.png)


`ggplot(`_your data_`, aes(x =`_x values_`, y =`_y values_`)) +` <br>
`geom_boxplot()` _the type of plot geometry desired_

Steps

1. Using `gm_df`, select the `lifeExp` column
2. Pipe (`%>%`) the result to `ggplot()`
3. Select the plot's `aes()`thetic values
    + `lifeExp` for the `x` values
        + a histogram's `y` are counts of its `x` values, so we don't provide them here
4. Add `geom_histogram()` as the geometry of the plot

```{r fig.cap="Figure 1"}
gm_df %>%                                     # data frame: Data
  select(lifeExp) %>%                         # columns to keep: Data
  ggplot(aes(x = lifeExp)) +                  # x values: Aesthetics
  geom_histogram()                            # histogram: Geometries
```




# `filter()` Rows

![](/post/2018-03-15-tidyverse-getting-your-feet-wet_files/filter.png)

## Quick Example

### Initial Data

```{r}
sample_df %>%
  select(country, lifeExp) %>%
  prettify()
```

### End Data

```{r}
sample_df %>%
  select(country, lifeExp) %>%
  filter(lifeExp > 75) %>%
  prettify(cols_changed = 2)
```


Use `filter()` to select rows using logic. Rows where a logical expression returns `TRUE` are kept and others are dropped.

* `filter()` rows where `numeric()` values are greater or lesser than another value
    + `filter()` `gm_df` to only keep rows where `gdpPercap < 500`

```{r}
gm_df %>%
  filter(gdpPercap < 500) %>%
  prettify(cols_changed = 6)
```

* `filter()` rows using multiple logical expressions where all must be `TRUE`
    + `filter()` `gm_df` to only keep rows where `year > 1990` _and_ `lifeExp < 40`
    + `,` and `&` are evaluated identically in `filter()`

```{r}
gm_df %>%
  filter(year > 1990, lifeExp < 40) %>%
  prettify(cols_changed = 3:4)
```

* `filter()` rows using multiple logical expressions where one must be `TRUE`
    + `filter()` `gm_df` to only keep rows where `pop < 10000` _or_ `gdpPercap > 100000`
    + `|` means _or_

```{r}
gm_df %>%
  filter(pop < 10000 | gdpPercap > 100000) %>%
  prettify(cols_changed = 5:6)
```

* `filter()` rows using a string
    + `filter()` `gm_df` to only keep rows where `year` is `1999` and `continent` is `"Europe"`
    + `==` means _is equal to_

```{r}
gm_df %>%
  filter(year == 1997 & continent == "Europe") %>%
  prettify(cols_changed = 2:3)
```

# `ggplot()` Exercise 2

![](/post/2018-03-15-tidyverse-getting-your-feet-wet_files/ggplot_exercise_1.png)

Steps

1. Using `gm_df`, select the `continent`, `country`, and `gdpPercap` columns
2. `filter()` the rows to only keep those where `continent == "Oceania"`
3. Pipe (`%>%`) the result to `ggplot()`
4. Select the plot's `aes()`thetic values
    + `country` for the `x` values
    + `gdpPercap` for the `y` values
4. Add `geom_boxplot()` as the geometry of the plot

```{r}
gm_df %>%                                         # data frame: Data
  select(continent, country, gdpPercap) %>%       # columns to keep: Data
  filter(continent == "Oceania") %>%              # rows to keep: Data
  ggplot(aes(x = country, y = gdpPercap)) +       # x and y values: Aesthetics
  geom_boxplot()                                  # box plot: Geometries
```

# `mutate()` Columns

![](/post/2018-03-15-tidyverse-getting-your-feet-wet_files/mutate.pngs)

## Quick Example

### Initial Data

```{r}
sample_df %>%
  select(country, pop) %>%
  prettify()
```

### End Data

```{r}
sample_df %>%
  select(country, pop) %>%
  mutate(pop_in_thousands = pop / 1000) %>%
  prettify(cols_changed = 3)
```


Use `mutate()` to manipulate column values and create new columns.

In order to `mutate()` a column, use the name of the column you are manipulating and set its value using `=`.

Here's a silly example:

* Add a new column to `gm_df`
    + `mutate()` `gm_df` to create a column named `planet` and set its value to `"Earth"`

```{r}
gm_df %>%
  mutate(planet = "Earth") %>%
  prettify(cols_changed = 7)
```

Since we have `gdpPercap` and `pop`, we can calculate the values for a `total_GDP` column.

* `mutate()` `gm_df` to set the results of a calculation on each row to a new column
    + multiply `pop * gdpPercap` and assign the result to `total_GDP` inside `mutate()`

```{r}
gm_df %>%
  mutate(total_GDP = pop * gdpPercap) %>%
  prettify(cols_changed = 7)
```

Typically, `mutate()` is used to perform operations across columns in each individual row. You can also use _summary functions_ to perform operations on individual columns (acting as vectors) that result in a vector that can be assigned to a column.

Makes sense, right??

Let's calculate the _z-score_ of each `gdpPercap` value for a specific year.

$$ z = \frac {x_i -\mu_x} {\sigma_x}$$

* $x$ = `gdpPercap`
* $\mu_x$ = the mean of $x$ = `mean(gdpPercap)`
* $\sigma_x$ = the standard deviation of x = `sd(gdpPercap)`

* Use a _summary function_ to perform a a calculation involving summary statistics of a column
    + subtract `mean(gdpPercap)` from `gdpPercap`
    + divide the result by `sd(gdpPercap)`
    + set the results as the values of a new column called `gdp_per_cap_z_score`

```{r}
gm_df %>%
  filter(year == 1977) %>%
  mutate(gdp_per_cap_z_score = (gdpPercap - mean(gdpPercap)) / sd(gdpPercap)) %>%
  prettify(cols_changed = 7)
```

Here are other functions that can be used similarly:

Summary Functions |
----------------- | -----------------
`first()`         | `min()`
`last()`          | `max()`
`nth()`           | `mean()`
`n()`             | `median()`
`n_distinct()`    | `var()`
`IQR()`           | `sd()`

# `ggplot()` Exercise 3

![](/post/2018-03-15-tidyverse-getting-your-feet-wet_files/ggplot_exercise_1.png)

Steps

1. Using `gm_df`, `select()` `country`, `year`, and `gdpPercap`
2. `filter()` the rows to keep only those where `country` is `"Korea, Rep."`, `"Korea, Dem. Rep."`, `"Japan"`, or `"China"`
3. Pipe the result to `ggplot()`
4. Select the plot's `aes()`thetic values
    + `year` for the `x` values
    + `gdpPercap` for the `y` values
    + __`country` for the `color` values__
* Add `geom_line()` as the geometry of the plot
* Add a `title` to the plot with `labs()`

```{r}
gm_df %>%
  filter(country %in% c("Korea, Rep.", "Korea, Dem. Rep.", "Japan", "China")) %>%
  mutate(total_GDP = pop * gdpPercap) %>%
  ggplot(aes(x = year, y = gdpPercap, color = country)) +
  geom_line() +
  labs(title = "GDP Over Time")
```

# `arrange()` Rows

## Quick Example

### Initial Data

```{r}
sample_df %>%
  select(country, gdpPercap) %>%
  prettify()
```

### End Data

```{r}
sample_df %>%
  select(country, gdpPercap)%>%
  arrange(gdpPercap) %>%
  prettify(cols_changed = 2)
```


Use `arrange()` to sort rows.

* `arrange()` by ascending number (smallest to largest)
    + `arrange()` `gm_df`'s `pop` column so that smallest populations are on top

```{r}
gm_df %>%
  arrange(pop) %>%
  prettify(cols_changed = 5)
```

* `arrange()` by `desc()` number (largest to smallest)
    + `arrange()` the `lifeExp` column so that largest values are on top

```{r}
gm_df %>%
  arrange(desc(lifeExp)) %>%
  prettify(cols_changed = 4)
```

* `arrange()` alphabetically
    + `filter()` `gm_df` to keep only those rows where `year == 2007` and `continent == "Americas"`
    + `arrange()` the `country` column alphabetically

```{r}
gm_df %>%
  filter(year == 2007, continent == "Americas") %>%
  arrange(country) %>%
  prettify(cols_changed = 2:3)
```


# `group_by()` for Grouped Data

![](/post/2018-03-15-tidyverse-getting-your-feet-wet_files/group_by.png)

## Quick Example

### Initial Data

```{r}
sample_df %>%
  select(country, continent, pop) %>%
  prettify()
```

### End Data

```{r}
sample_df %>%
  select(country, continent, pop) %>%
  group_by(continent) %>%
  mutate(pop_by_continent = sum(pop)) %>%
  ungroup() %>%
  arrange(pop_by_continent) %>%
  prettify(cols_changed = 4)
```


`group_by()` allows us to group rows together based on column values.

Let's say we wanted to compute summary values for each country for all years.

* Calculate the `mean_gdp_per_cap` of each `country` with `group_by()`
    + take `gm_df` and `group_by()` `country` to group rows of the same country together
    + use `mean()` to calculate the `mean_gdp_per_cap`
    + `ungroup()` the rows
        + a habit you want
    + keep only those rows with `distinct()` combinations of `country` and `mean_gdp_per_cap`
        + `distinct()`'s default is to only keep columns used as arguments

```{r}
gm_df %>%
  group_by(country) %>%
  mutate(mean_gdp_per_cap = median(gdpPercap)) %>% 
  ungroup() %>%
  distinct(country, mean_gdp_per_cap) %>% 
  prettify(cols_changed = 2)
```

# `ggplot()` Exercise 4

![](/post/2018-03-15-tidyverse-getting-your-feet-wet_files/ggplot_exercise_1.png)

Steps

1. Using `gm_df`, `group_by()` the `continent` and `year`
2. `mutate()` to add a column called `mean_gdp` for the average GDP of each continent
3. `ungroup()` the data, because this is a habit that will save you headaches later
4. Keep only `distinct()` combinations of `continent`, `year`, and `mean_gdp`
3. Pipe the result to `ggplot()`
4. Select the plot's `aes()`thetic values
    + `year` for the `x` values
    + `mean_gdp` for the `y` values
    + `continent` for the `color` values
5. Add `geom_line()` as the geometry of the plot
6. Add a `title` and a `caption` (for the source of the data) to the plot with `labs()`

```{r}
gm_df %>%
  group_by(year, continent) %>%
  mutate(mean_gdp = mean(gdpPercap)) %>%
  ungroup() %>%
  distinct(continent, year, mean_gdp) %>%
  ggplot(aes(x = year, y = mean_gdp, color = continent)) +
  geom_line() +
  labs(title = "Mean GDPs by Continent Over Time",
       caption = "Source: Free material from www.gapminder.org")
```

# `summarize()`

![](/post/2018-03-15-tidyverse-getting-your-feet-wet_files/summarize.png)

## Quick Example

### Initial Data

```{r}
sample_df %>%
  select(country, continent, lifeExp, pop) %>%
  prettify()
```

```{r}
sample_df %>%
  select(country, continent, lifeExp, pop) %>%
  group_by(continent) %>%
  summarise(max_pop = max(pop),
            mean_life_exp = mean(lifeExp)) %>%
  prettify(cols_changed = 2:3)
```


Now that we know how to use `group_by()`, we can `summarize()` data by group. This can be done using all of the _summary functions_ seen earlier.

Summary Functions |
----------------- | -----------------
`first()`         | `min()`
`last()`          | `max()`
`nth()`           | `mean()`
`n()`             | `median()`
`n_distinct()`    | `var()`
`IQR()`           | `sd()`

* Calculate some summary statitics for each continent.
    + take `gm_df` and `group_by()` `continent`
    + using `summarize()` or `summarise()`, calculate:
        + `count` with `n()`
        + `mean_pop` with `mean()`
        + `max_gdp_per_cap` with `max()`

```{r}
gm_df %>%
  group_by(continent) %>%
  summarise(count = n(),
            mean_pop = mean(pop),
            max_gdp_per_cap = max(gdpPercap)) %>%
  prettify(cols_changed = 2:4)
```

# `ggplot()` Exercise 5

![](/post/2018-03-15-tidyverse-getting-your-feet-wet_files/ggplot_layers_all.png)

Steps

1. Using `gm_df`, `filter()` the data to remove rows where `continent` is not `"Oceania"`
3. `group_by()` `continent` and `year` 
4. `summarize()` the groups by calculating them `mean()` of `pop`
5. `ungroup()` the data, because this is a habit that will save you headaches later
6. Pipe the results to `ggplot()`
7. Select the plot's `aes()`thetics
    + `year` for the `x` values
    + `mean_pop` for the `y` values
    + `continent` for the `color` values
8. Add `geom_line()` for the first geometry
9. Add `geom_point()` for the second geometry
10. Change the theme by adding `theme_minimal()`
11. Using `facet_wrap()`, split the plot into panels for each `continent`
    + `~` is used as a `formula` to select the facet variable
12. Add a `title` and a `caption` with `labs()`


```{r}
gm_df %>%
  filter(continent != "Oceania") %>%
  group_by(continent, year) %>%
  summarise(mean_pop = mean(pop)) %>%
  ungroup() %>%
  ggplot(aes(x = year, y = mean_pop,
             color = continent)) +
  geom_line() +
  geom_point() +
  theme_minimal() +
  facet_wrap(~ continent) +
  labs(title = "Mean Continent Populations over Time",
       caption = "Source: Free material from www.gapminder.org")
```



